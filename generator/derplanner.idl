// Web IDL code goes here


// Type IDs supported by fact database.
enum Type
{
    "Type_None",
    "Type_Count"
};

[Internal="int"] enum FactArity
{ 
    "Max_Fact_Arity" 
};

// Format of the fact tuple.
[Internal="plnnr::Fact_Type"]
interface FactType
{
    // number of parameters.
    attribute int num_params;
    // type of each parameter.
    //Type types[Max_Fact_Arity];
};

[Internal="plnnr::Fact_Handle"]
// Points to a fact tuple in Fact_Database.
interface FactHandle
{
    // index of table in Fact_Database.
    attribute int table;
    // index of entry in Fact_Table.
    attribute int entry;
};

[Internal="plnnr::Fact_Table"]
// Collection of tuples of a single fact type.
interface FactTable
{
    // type (format) of the stored data tuples.
    //Fact_Type       format;
    // current number of entries stored.
    //attribute int        num_entries;
    // total allocated number of entries.
    //attribute int        max_entries;
    // block of memory accommodating entries' data.
    //void*           blob;
    // tuples in SOA layout.
    //void*           columns[Max_Fact_Arity];
    // allocator.
    //Memory*         memory;
    [Internal="plnnr::add_entry", CObject]void addEntry( int i );
    [Internal="plnnr::add_entry", CObject]void addEntry( int a, int b );
    

};

// A set of fact tables.

[Internal="plnnr::Memory_Default"]
interface MemoryDefault {
    void MemoryDefault();
};

[Internal="plnnr::Database_Format"]
interface DatabaseFormat {
    [Internal="num_tables"] attribute int numTables;
};

[Internal="plnnr::Fact_Database"]
interface FactDatabase
{
    void FactDatabase ();

    //plnnr::init(&db, &default_mem, &domain->database_req);
    [Internal="plnnr::init", CObject] void init(MemoryDefault mem, DatabaseFormat fmt);
    [Internal="plnnr::find_table", CObject, Const] FactTable findTable(String name);

    // current number of tables.
    attribute int        num_tables;
    // total allocated number of tables.
    attribute int        max_tables;
    // seed value generated by compiler to make unique hashes.
    attribute int        hash_seed;
    // fact name hash per each table.
    //uint32_t*       hashes;
    // fact name per each table.
    //const char**    names;
    // table data.
    //Fact_Table*     tables;
    // linear block of memory accommodating database data (not including tables data).
    //void*           blob;
    // allocator.
    //Memory*         memory;
};

[Internal="plnnr::Domain_Info"]
// Domain info provided by the generated domain code.
interface DomainInfo
{
    // generated tasks info.
    //Task_Info           task_info;
    // required fact database format.
//    DatabaseFormat     database_req;
    
    [Internal="domain_info_get_format", CObject] DatabaseFormat getFormat();

    // symbols used in domain.
   // Symbol_Table        symbols;
};
 


[NoDelete]
interface TravelDomain {
    [Internal="travel_init_domain_info", Static] void init();
    [Internal="travel_get_domain_info", Static, Const] DomainInfo get();

};


[Internal="plnnr::Planning_State_Config"]
interface PlanningStateConfig {
    void PlanningStateConfig();

    // maximum expansion depth.
    attribute int    max_depth;
    // maximum plan length.
    attribute int    max_plan_length;
    // maximum size of the domain to database binding (i.e. table indices mapping).
    attribute int    max_bound_tables;
    // maximum size of the expansions data block (arguments & preconditions).
    attribute int    expansion_data_size;
    // maximum size of the plan data block (arguments & preconditions).
    attribute int    plan_data_size;
};